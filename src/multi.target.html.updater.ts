import { Compiler, Compilation, Chunk ,ChunkGroup, Plugin } from 'webpack';
import { BeforeHtmlGenerationData, AlterAssetTagsData, HtmlTag } from 'html-webpack-plugin';
import { TapableCallback } from 'tapable';
import { BrowserProfile } from './browser.profiles';

import { CHILD_COMPILER_PREFIX, PLUGIN_NAME } from './plugin.name';
import { Target } from './webpack.babel.multi.target.options';

export class MultiTargetHtmlUpdater implements Plugin {

    constructor(
        private targets: Target[],
        private compilationBrowserProfiles: { [childCompilerName: string]: BrowserProfile },
    ) { }

    public apply(compiler: Compiler): void {

        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation: Compilation) => {

            // html-webpack-plugin helpers
            compilation.hooks.htmlWebpackPluginBeforeHtmlGeneration.tapAsync(PLUGIN_NAME,
                (htmlPluginData: BeforeHtmlGenerationData, callback: TapableCallback) => {
                    // add assets from the child compilation
                    compilation.children
                        .filter((child: Compilation) => child.name && child.name.startsWith(CHILD_COMPILER_PREFIX))
                        .forEach((child: Compilation) => {

                            const jsChunkGroups = child.chunkGroups
                                .filter((chunkGroup: ChunkGroup) => {
                                    // webpack doesn't export Entrypoint :/
                                    return chunkGroup.constructor.name === 'Entrypoint' &&
                                        chunkGroup.chunks.find(chunk => !!chunk.files.find(file => file.endsWith('.js')));
                                });

                            const jsChunks = jsChunkGroups
                                .reduce((result, group) => {
                                    result.push(...group.chunks);
                                    return result;
                                }, []);

                            // the plugin already sorted the chunks from the main compilation,
                            // so we'll need to do it for the children as well
                            let sortedChunks: Chunk[] = htmlPluginData.plugin.sortChunks(
                                jsChunks,
                                htmlPluginData.plugin.options.chunksSortMode,
                                jsChunkGroups,
                            );

                            // generate the chunk objects used by the plugin
                            const htmlChunks = sortedChunks.reduce((result: any, chunk: Chunk) => {
                                let entry = chunk.files.find((file: string) => file.endsWith('.js'));
                                result[chunk.name] = {
                                    css: [],
                                    entry,
                                    hash: chunk.hash,
                                };
                            }, {});
                            Object.assign(htmlPluginData.assets.chunks, htmlChunks);

                            // add the asset names form the child
                            let assetNames = sortedChunks.map(chunk => chunk.files.find((file: string) => file.endsWith('.js')));
                            htmlPluginData.assets.js.push(...assetNames);
                        });

                    return callback(null, htmlPluginData);
                });

            compilation.hooks.htmlWebpackPluginAlterAssetTags.tapAsync(PLUGIN_NAME,
                (htmlPluginData: AlterAssetTagsData, callback: TapableCallback) => {
                    // update script tags for module loading
                    let children = compilation.children.filter(child => child.name.startsWith(CHILD_COMPILER_PREFIX));

                    htmlPluginData.head
                        .concat(htmlPluginData.body)
                        .filter((tag: HtmlTag) => tag.tagName === 'script')
                        .forEach((tag: HtmlTag) => {
                            let child = children.find(child => !!child.assets[tag.attributes.src]);
                            let isModernBundle;
                            if (child) {
                                // if the tag is for a bundle generated by a child compilation, we can determine
                                // whether it is a "modern" bundle by checking the target browserProfile type
                                isModernBundle = this.compilationBrowserProfiles[child.name] === 'modern';
                            } else {
                                // if the tag is for a bundle generated by the main compilation, we determine whether
                                // it is a modern bundle by checking if any of the child compilations are used to generate
                                // a legacy bundle. If that is the case, then (for now, at least), it is safe to assume
                                // that the main compilation was used to create a modern bundle
                                isModernBundle = !!this.targets.find(options => options.browserProfile === 'legacy');
                            }
                            if (isModernBundle) {
                                tag.attributes.type = 'module';
                            } else {
                                tag.attributes.nomodule = true;
                            }
                        });
                    return callback(null, htmlPluginData);
                });

        });
    }

}
